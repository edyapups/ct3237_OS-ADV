Приложение обращается к ядру через интерфейс системных вызовов. 
==Системные вызовы== - форма api, представленные в виде прототипов функций. Вызов функций происходит специальным образом. 
С точки зрения программирования системный вызов -- вызов функции с возможно нулевым числом параметров. 

Ядро общается с устройствами через драйвера. 

Есть режимы работы процессора, которые имеют прямое отношение к ядерному коду и пользовательскому коду. Режимы включаются при помощи определенных инструкций. Когдя ядро загружается - сразу включает режим ядра. Приложения, которые загружаются после ядра, работают в режиме пользователя.
Режим гипервизора нужен для работы виртуальных машин. 
Режим firm ware (режим устройств) 
В процессоре arm уровни обозначаются 
У кода в режиме ядра много привилегий, позволяющие регулировать частоты ядер, например.
В режиме пользователя некоторые возможности ограничены, например ограничено управление прерываниями.

С точки зрения оперативной памяти есть тоже две разновидности: ядерный взгляд и пользовательский. 
Разница в доступе: ядерное пространство в большей части не доступно приложениям, а вот ядро к памяти приложений обращаться может. Есть перекрытие в области памяти между ядерной и пользовательской для коммуникации между ядром и пользователем.


Как ядро организовоно. 
==Монолитное ядро== - все модули (части) ядра имеют доступ к памяти друг друга, если при таком дизайне какая-то одна функциональная часть ядра испортит что-то другой, то что-то может сломаться. Может показаться, что это странный дизайн (архитектура), у него есть свои коммерческие и исторические причины. Такой дизайн работает очень быстро из-за наличия доступа ко всей памяти и устройствам сразу. 

Альтернатива - ==micro-kernel ==(микро ядро) - модули (блоки) ядра работают как отдельные процессы (приложения) и доступ между ними ограничен, т.е. если один блок сломается, то микро ядро может обнаружить нарушение и перезагрузить компоненту. 
В такой архитектуре ядро все равно существует, но она сравнительно маленькая. 
При таком дизайне скорость работы такой ОС заметно ниже, чем в монолитном, хотя надежность выше. По историческим/коммерческим причинам такой дизайн не очень распространен и используется там, где надежность очень важна (например в авиационной и ядерно отрасли).

Монолитное ядро все равно может быть модульным. Модули могут динамически подгружаться или выключаться. Модульный подход позволяет повышать и надежность ПО, и позволяет легче вести разработку.

Для потребительских нужд чаще всего используется монолитное ядро (например Linux).
Windows заявляется как гибридная архитектура, но на самом деле гибридность - скорее PR ход, так как микро ядро само по себе маленькое, но внутри монолитное. 

==Многопроцессность== - параллельное исполнение нескольких процессов, как в ядре, так и вне его.
Многопроцессность реализуется через смену задачи во время I/O блокирующих вызовов.
Многопроцессность бывает cooperatiove (программы пишутся с вызовом функции, передающей процессор другому) и preemptive (процессор дает программам какое-то количество времени и может в любой момент может переключить с одного процесса на другой). 
CFS - популярный планировщик в ядре Linux. Он каждому процессу дает примерно одинаковый кусочек времени.
В Android такой подход не подходит, так как существует много процессов, контролирующих пользовательский интерфейс и их прерывание будет мешать, поэтому планировщик нечестный. 
Если какой-то процесс начинает перемещаться между ядрами, то нужно перемещать и процессорный кэш, что может оказаться не очень хорошо для батареи - еще один фактор, почему на мобильных устройствах используются другие принципы планирования. 

> Ядро Linux 2.4 было non-preemptive. 
> - Процесс работает до тех пор, пока не решит передать управление. Такое свойство гарантируется в модулях ядра. Но процесс может не отдать управление, что заблокирует все остальные.
> - Не подходят для реального времени и не гарантирует адекватного времени отклика.
> - Владение CPU полностью в руках определенного процесса. 
> - В таких ядрах временная остановка и перепланирование не разрешается. Поэтому время ответа не детерминировано. Поэтому подходит для задач, где не гарантируется время отклика.
> - Более приоритетная задача может ждать достаточно дольше не смотря на ее приоритет.
> - Разделяемая память требует семафоров.
> - Может использовать non-reentrant код.
> - В силу ряда условий легче разрабатывать код для таких ядер. 
> - Non-preemptive ядра легче разрабатывать.
> - В реальных сценариях обладает меньшей надежностью и полезностью. 

- В preemptive любой процесс может быть приостановлен в любой момент времени (кроме системных вызовов и операций ввода-вывода).
- Больше подходят для использования в реальном времени.
- С приоритетами все в порядке.
- Время отклика детерминировано. 
- Как правило не требует механизмов синхронизации. 
- Такие ядра труднее разрабатывать.
- Более надежно и полезно.
- Не может использовать non-reentrant код.

Ассиметричная многопроцессность - процессор (или ядро) выделяется для ядра, а остальные процессоры (ядра) выделяются для приложений. 
Если ядро работает на одном процессоре, то ядру легче гарантировать скорость работы и обработку прерываний. Часть такой симметричности есть в Android - обработка прерываний назначается на отдельное ядро. 

Симметричная многопроцессность позволяет ядру и процессам использовать процессоры (ядра) как им удобно.

Когда много ядер, тогда перед разработчиком возникает проблема масштабируемости ядра. Применяются методы:
- Использование lock-free алгоритмов. 
- Использование fine grained locking для мест с высокой конкурентностью.

Адресные пространства RAM.

Физическое пространство - очевидно.

Виртуальное адресное пространство - 
- Адресное пространство как его видит процесс или процессор. 
- Существуют специальные аппаратные механизмы, позволяющие процессу и процессору видеть память как непрерывную. 
- Для адресации используются страницы, размер которых обычно 4кб. 
- Ядро и пользователь разделяют часть виртуального пространства.
- Такой механизм позволяет в приложении иметь возможность программировать так, как будто у нас размер памяти - несколько терабайт.

Одна из функций ОС в том, чтобы обеспечить такой механизм виртуализации памяти. 
Такие механизмы -- структуры данных и возможность переназначать некоторые виртуальные страницы на физические.

Ядро может использовать как виртуальную память, так и физическую. Аллокаторы памяти ядра при выделении непрерывного куска памяти >4кб ищут кусок памяти, который непрерывен физически, но это не всегда возможно, поэтому аллокация может получить отказ. 

Отображение физических страниц на виртуальную делается с помощью таблиц косвенности.
Каждая табличка косвенности занимает одну страницу. 
Получается иерархическая структура данных. (тут какие-то циферки, надо смотреть презентацию).

Контекст исполнения процесса - содержимое регистров, содержимое стека, содержимое кучи.  (регистр + кэш)
Контекст должен быть сохранен каждый раз, когда переходит исполнение.

Контекст прерывания нужен для обработки действия пользователя (каждое нажатие клавиши вызывает прерывание, например), вызывается быстро и передает нуждающимся процессам. Всегда работает в режиме ядра. 

Стек пользователя, ядра и прерывания.
Если пользовательские стеки достаточно большие, то у ядра стек, как правило, очень небольшой (например 8кб). Такой маленький размер стека ставит определенные требования разработчикам ядра. 

paging&swapping нужен для обеспечения возможности приложениями распоряжаться большим объемом памяти, чем есть на самом деле.

Одна память может использоваться активно - горячая, другая неактивно - холодная.

Получается, что та память, которая сейчас для исполнения не нужна, может быть вытеснена на диск, что освобождает физическую память.

Обычно код и статические данные не вытесняются.

